package main

import (
	"bytes"
	"flag"
	"io/ioutil"
	"net/http"
	"os"
	"os/signal"
	"syscall"

	"github.com/telapi/flumine/logger"
)

var (
	uri   = flag.String("uri", "", "URI you wish to use to access smpp dumps. By default it's autogenerated.")
	iface = flag.String("i", "any", "Interface you wish to invoke. Use ifconfig to figure out which one. Default is any.")

	srvkill = make(chan os.Signal, 1)
	packets = make(chan []string)
)

func main() {

	flag.Parse()
	signal.Notify(srvkill, os.Interrupt)
	signal.Notify(srvkill, syscall.SIGTERM)

	furi := *uri

	if err := ValidateUri(*uri); err != nil {
		// If lenght of uri is empty we are going to attempt generate uri
		if len(*uri) < 1 {
			Debug("Provided URI is empty. We are going to generate new one now ...")
			furi = GenerateUri()
		} else {
			Error("Got error while validating uri: %s", err)
			return
		}
	}

	tshark, err := NewTshark(*iface)

	if err != nil {
		Error("Could not create new Tshark due to: %s", err)
		return
	}

	Debug("Starting SMPPd CLI for (uri: %s)", furi)

	go func() {
		<-srvkill

		close(packets)

		logger.Warning("SMPPd CLI is now stopped!")
		os.Exit(0)
	}()

	go func() {
		for {
			select {
			case packet := <-packets:
				Debug("Got (packet: %s). Preparing post ...", packet)

				//msg := ""

				for _, p := range packet {
					Debug("%s", p)
				}

				req, err := http.NewRequest("POST", "http://webhookr.com/3QeA51r", bytes.NewBuffer(packet))
				req.Header.Set("Content-Type", "text/plain")

				client := &http.Client{}
				resp, err := client.Do(req)

				if err != nil {
					Error("Could not send POST request due to: %s", err)
					return
				}

				defer resp.Body.Close()

				Debug("Got Response Status: %s", resp.Status)
				Debug("Got Response Headers: %v", resp.Header)

				body, _ := ioutil.ReadAll(resp.Body)
				Debug("Got Response Body: %s", string(body))

				if resp.Status == "200 OK" {
					Notice("Packet successfully published! (data: %s)", string(packet))
				}

			}
		}
	}()

	if err := tshark.Capture(packets); err != nil {
		Error("Could not start tshark due to: %s", err)
		return
	}

	Notice("Tshark consumer successfully started!")
}
